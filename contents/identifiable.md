# Identifiable Protocol(SE-0261)

```swift
strcut Animal {
	let name: String
	let age: Int
}
```

위의 Animal 구조체의 인스턴스를 만들어보자

```swift
let 🐶 = Animal(name: "토리", age: 5)
let 🐰 = Animal(name: "토리", age: 5)
```

이제 Eqautable 프로토콜을 채택하고 둘을 비교해보면, 서로 다른 동물을 의도했더라도 타입에 이름과 나이까지 같으니 true로 나온다

이번엔 고유의 값을 통해 각각을 구분할 수 있도록 동물등록번호를 id 프로퍼티로 추가해보자

```swift
strcut Animal {
	let id: Int
	let name: String
	let age: Int
}

let dogA = Animal(id: 1, name: "토리", age: 5)
let dogB = Animal(id: 1, name: "토리", age: 6)

dogA == dogB // false
dogA.id == dogB.id // true
```
## 안정적 정체성(Stable Identity)

지금까지 살펴본 것처럼 값 타입은 상태를 통해 동등성만을 비교할 뿐이다

하지만 상태는 나이처럼 값이 변할 수 있는 가능성이 내포되어 있으며, id 같은 고유의 식별자가 없다면 여전히 개와 토끼를 같은 대상으로 판단하는 것과 같은 문제가 발생할 수 있다

반면, 참조 타입의 경우 힙 메모리에 저장된 고유 주소값을 통해 정체성을 확보하고, 상태의 변화와 관계없이 동일한 대상이닞 아닌지 식별한다

그런데 참조 타입이어도 여러 프로세스에 분산되어 처리되거나 저장했던 값을 불러왓을 때처럼 메모리 주소만으로도 그 대상의 정체성을 완전히 식별할 수 없는 경우들도 발생한다

이런 경우 별도의 식별자가 필요할 수도 있다

따라서 단일 개체에 대해 상태가 변화하는 것과 별개로 안정적인 정체성 또는 식별자를 제공하도록 이 Identifiable 프로토콜이 추가되었다

이 프로토콜을 추가하는 것만으로 값 타입도 개념적으로 참조 타입과 같은 정체성을 가질 수 있게 되고, 참조 타입도 더 명확하게 식별할 수 있다

결국 이를 바탕으로 서로 다른 개체 간에 명확하게 구분할 수 있을 뿐만 아니라, 시간 흐름에 따라 각 개체의 상태 변화 역시 관리할 수 있게 된다

동일 식별자를 지닌 개체가 특정 시점의 값과 또 다른 시점에서의 값이 서로 다르다면 그 상태 변화를 측정할 수 있겠죠

## Identifiable Protocol

프로토콜에 대해 살펴보자

Identifiable 프로토콜은 Hashable 프로토콜을 준수하는 id 프로퍼티 하나만 가지는 매우 단순한 프로토콜이다

이 프로토콜을 채택한 타입은 고유한 개체를 구분하기 위해 비교 알고리즘에 이 id를 사용하게 된다

따라서 id가 다르면 서로 다른 대상인 것이고, 값이 다르더라도 id가 같다면 같은 개체로 여겨지게 되는 것이다

## AnyObject

Identifiable 프로토콜은 AnyObject, 즉 참조 타입에 한해 id 프로퍼티에 Object Identifier라는 구조체를 사용한다

이 경우 기본값으로는 메모리 주소를 반환하게 된다

