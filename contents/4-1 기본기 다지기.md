# SwiftUI Preview

## 프리뷰 동작 과정

```swift
struct ContentView_Previews: PreviewProvider {
	static var previews: some View {
		ContentView()
	}
}
```

**1** 현재 소스 에디터에 PreviewProvider 프로토콜을 준수하는 타입이 존재하는지 확인

**2** PreviewProdiver 프로토콜의 필수 구현 사항인 previews 타입 프로퍼티 

**3-1** 액티브 스킴의 목적지로 선택한 시뮬레이터 또는 맥에 연결한 기기의 형태로 프리뷰 컨테이너 렌더링, 이 때 목적지가 Generic iOS Device인 경우는 iPhone 8이 기본값

**3-2** 리뷰 컨테이너를 직접 지정해줄 경우 3-1에서 선택한 기기를 무시하고 해당 기기 형태로 렌더링

### Swift 최적화 레벨

프리뷰가 사용되는 시점을 생각해 보면 개발 단계에 필요한 것이지, 실제 출시될 앱에 필요한 부분은 아니다

그런데 매번 앱에서 불필요한 코드가 포함된다면 빌드 시간도 더 많이 걸리고 용량도 증가한다

SwiftUI가 나왔던 초기에는 다음 코드처럼 조건부 컴파일 블록(Conditional Compilation Block)을 이용해 디버그 모드에서만 프리뷰를 컴파일하도록 지정했었다

하지만 그것이 불편하고, 디버그 외에도 다른 커스텀 플래그들을 만들어서 사용하는 상황들까지 고려한다면 썩 좋은 방법이 아니었다

그래서 Swift 컴파일러의 최적화 레벨이 생긴 것이다

이 최적화 레벨을 기준으로 프리뷰의 컴파일 여부를 결정하는 것이다

디버그 모드로 빌드할 때는 최적화를 하지 않는 `No Optimization [-Onone]`,

릴리즈 모드로 빌드할 때는 최대한 빠른 속도를 위한 최적화 방식인 `Optimize for Speed [-O]`가 적용되는데,

프리뷰는 디버그 모드일 때만 함께 빌드된다

### 자동 프리뷰 갱신

파일의 탑 레벨이나 구조체 / 클래스의 구현 범위에서는 키워드, 속성, 프리프로세서 구문에 대한 수정같은 일부 예외를 졔외하면 어떠한 작은 변화라도 일어나는 순간에 자동 갱신이 중단된다

해당 범위 내에서는 한 글자라도 입력 / 삭제하거나 개행 또는 공백을 추가하면 다시 빌드해야 하는 상황을 겪게 될 것이다.

하지만 함수나 메소드 범위 안에서 코드를 변경하는 경우에는 오히려 이와 반대로, 모듈을 다시 빌드하지 않고도 대부분의 상황에서 자동 갱신 기능의 혜택을 누릴 수 있다

연산 프로퍼티는 입력값이 없는 함수와 동일하기 때문에 연산 프로퍼티에서의 변경도 마찬가지다

## 프리뷰 수식어 살펴보기

### 기기 지정하기

`.previewDevice(PreviewDevice(rawValue: "~~~"))`를 이용하면 된다

만약 여러기기로 보고싶다면

Group으로 묶고 위의 메소드를 호출하면된다

### 이름 지정하기

`.previewDisplayName("")`를 이용해서 정해주면된다

### 레이아웃 변경하기

**device**

기본값. 컨테이너가 기기 본래의 크기와 형태로 나타난다

**sizeThatFits**

컨테이너를 프리뷰의 크기에 맞춰서 유동적으로 조절한다

**fixed(width:height:)**

지정한 너비와 높이에 맞춰서 컨테이너 크기를 고정한다

# EnvironmentValues

SwiftUI에서는 뷰를 구성하는데 필요한 각종 환경 설정과 관련된 정보를 EnvironmentValues 타입이 관리한다

`struct EnvironmentValues: CustomStringConvertible { ... }`

기존에는 UITraitCollection을 비롯해 다양한 클래스에서 나눠서 사용하고 관리되던 속성들을 이제 EnvironmentValues 하나에 모두 담아서 쉽게 접근하고 관리할 수 있다

이 EnvironmentValues는 프레임워크에 의해 별도로 관리되고 있으므로 어떤 뷰에서든 접근할 수 있는데, 이 때 얻게 되는 값은 상위 계층의 뷰가 가진 환경 요소를 그대로 상속받게 된다

따라서 윈도우 또는 윈도우의 루트 뷰와 같은 최상위 뷰에서 적용된 값은 모든 자식 뷰에 영향을 주게 된다

단, 하위 계층에 있는 뷰에서 개별적으로 다른 환경을 구성했다면 우선하여 사용하게 된다

